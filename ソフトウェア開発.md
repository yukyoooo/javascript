# ソフトウェア開発

## 開発工程
1. 要求の収集と分析
   - 機能要件（ソフトウェアが何をすべきか）と非機能要件（ソフトウェアがどの程度それを行うべきか）の両方を特定することが重要
2. 設計
   - ソフトウェアがどのように構成され、設計されるか計画を作成します。この計画は、前フェーズで特定された要件に基づいています。これにはダイアグラム、フローチャート、スケッチ、UMLなどのツールや、技術的な詳細、テストプラン等が含まれ
   - ソフトウェアの構築を開始する前に、慎重に計画を立て、モデル化
3. 実装
4. テスト
5. デプロイメント
6. メンテナンス

## アジャイル開発
### 原則
- 顧客満足：顧客のニーズと要求を満たす製品を提供することに主眼を置きます。
- 変化の受け入れ：要件や優先順位の変更に柔軟に対応できるように設計されています。
- 実用的なソフトウェアの提供：各イテレーションの終了時に、テストと評価が可能な実用的な製品を提供することを目標とします。
- コラボレーションとコミュニケーション：開発チーム、利害関係者、顧客が密接に連携し、プロジェクトが計画通りに進行しているか、全員が同じ考えを持っているかを確認します。
- フィードバックへの対応：開発チームは、顧客や利害関係者からのフィードバックをもとに、ソフトウェアを改善し、必要に応じて変更を加えます。

### 一般的なプラクティス
- スプリント計画：チームは、通常 1 週間から 4 週間の各反復（スプリント）において行う作業を計画します。
- スタンドアップミーティング：チームは定期的にミーティングを開き、進捗状況を話し合い、問題を特定して解決し、次の日の計画を立てます。
- 継続的な統合とテスト：コードの変更を頻繁に統合し、ソフトウェアが期待通りに動作することを確認するために継続的にテストを行います。
- レトロスペクティブ：各反復の終わりに、チームは進捗状況をレビューし、何がうまくいき、何がうまくいかなかったかを特定し、次のスプリントに向けて調整を行います。

### フレームワーク
- マイルストーン
  - マイルストーンは、プロジェクトのタイムラインにおける大きなイベントであり、主要な目標や成果物の完成を意味します。通常、1 ヶ月から 3 ヶ月で達成されます。
- スプリント
  - スプリントは、通常 2 週間から 4 週間の小さな仕事の塊です。スプリントでは、マイルストーンの達成に必要な一連のタスクや目標を達成するために、チームは協力し合って作業を行います。
- タスク
  - タスクは、より大きな目標を達成するために必要な個々の作業単位です。通常、1 日から 7 日で完了します。

マイルストーンが設定されると、スプリントと呼ばれる達成可能な小さなタスクに分解する。毎日または毎週、定期的にミーティングを開き、これらのタスクの進捗を確認し、問題があれば解決し、潜在的な問題を早期に発見します。スプリントの終わりには、チームと利害関係者が一堂に会し、すべてのタスクが成功裏に完了したかどうかを評価する最終ミーティングを開催する。このミーティングは完成したソフトウェアのデモンストレーションも兼ねる。
最後に、各スプリント終了後に、チームは何がうまくいき、何が改善され、次のスプリントに何をコミットすべきかを振り返るために、振り返りのミーティングを行います。

## ソフトウェア要件
- 機能要件
  - システムが行うべきことや実行できる具体的なアクション
  - ユーザーが記録を作成、編集、削除、レポート作成など
- 非機能要件
  - システムがどれだけ優れたパフォーマンスを発揮すべきかや品質に関する属性
  - セキュリティ、信頼性、使いやすさ、パフォーマンス、拡張性
- 要件テンプレート 
  - 背景：プロジェクトがどのように始まり、どのようにビジネスニーズやサービスが特定されるに至ったかを説明します。
  - 目的：システムの目的は何か、何が達成されるのか、製品がどのように使用されるのかを説明します。
  - 機能要件仕様書：システムが持つ機能要件を列挙したものです。
  - 非機能要件仕様書：システムが持つ非機要件のリストです。

# ソフトウェア設計
1. 要件分析：システムおよびユーザーの要件と制約を理解します。
2. アーキテクチャ設計：ソフトウェアシステムとそのサブシステムの全体的な構造を定義します。
3. 詳細設計：ソフトウェアシステムの各コンポーネントやモジュールの詳細な機能・動作を定義します。
4. データ設計：ソフトウェアシステムが必要とするデータ構造やアルゴリズムを設計します。
5. ユーザーインターフェース設計：ソフトウェアシステムのユーザーインターフェースとユーザーエクスペリエンスを設計します。
6. テストと検証：設計が要件と目的を満たしていることを確認するためのテストと検証を行います。

## アーキテクチャ
- システム要件
  - ソフトウェアが何を行い、どのような機能を持つ必要があるかを説明する。これらの機能要件、非機能要件を満たすように設計する必要がある。
- スケーラビリティ(拡張性)
  - システムは拡大する必要がありますか？どれくらいのユーザー数とデータ量を考慮すべきですか？システムのコードベースは問題なく大きくなることができますか？もしスケーラビリティが求められる場合、システムが成長するにつれて増加する作業量、ユーザートラフィック、およびデータ量を処理できるようにする必要があります。水平スケーリングなどの技術が適用されます。
- 保守性
  - アーキテクチャは保守性のために設計される必要があります。つまり、システムに必要な変更やアップデートを容易に行えるようにする必要があります。全体的なシステムに支障をきたさずに変更ができることが求められます。これは全てのシステムに共通する要件であり、そのために一般的なソフトウェアのベストプラクティスが採用されます。具体的には、低い結合度、高い凝集度、そして自己文書化されたコードなどが重視されます。
- セキュリティ
  - ソフトウェアアーキテクチャは、セキュリティを考慮して設計される必要があります。これには、攻撃からシステムを保護すること、データのプライバシーと整合性を確保すること（正確で一貫性のあるデータ、データ損失の防止）、関連する規制に準拠することなどが含まれます。システムによってはセキュリティの制約が異なる場合もありますが、すべてのシステムで最低限のセキュリティを考慮する必要があります。
- パフォーマンス
  - アーキテクチャは、システムがタイムリーかつ効率的に機能を実行できるように、高いパフォーマンスを発揮できるように設計する必要があります。規模や段階に応じて、開発前に性能要件を設定し、ソフトウェアがスケールするにつれて、システムのスケールに合わせて最小要件のベンチマークとして機能させることができます。
- 統合性
  - 他のシステムやマイクロサービスとの統合の予定はありますか？その場合、ソフトウェア・アーキテクチャは他のシステムやアプリケーションと容易に統合できるように設計する必要があり、システムがエコシステムの他の部分と相互作用できることを保証する必要があります。
- 技術スタック
  - アーキテクチャに使用する技術スタックは、プラットフォーム、信頼性、保守性、使いやすさなどの要素を考慮し、慎重に選択する必要があります。開発チーム。アーキテクチャは、開発チームを念頭に置いて設計する必要があり、チームのスキルや専門性に合わせて、開発チームが実装できるようにする必要があります。
- 開発チーム
  - アーキテクチャは、開発チームのスキルと専門知識に合わせて設計される必要があります。そして、チーム自身が実装できるようにすることが重要です。

## アーキテクチャスタイル
- データ中心型アーキテクチャ
  - データ中心型アーキテクチャ（data centered architecture）では、データが中心となり、アプリケーション、サービス、インターフェースなどの他のシステムコンポーネントは、データとの連携や操作を目的として設計されます。このアプローチにより、データが常にシステムの最も重要な要素であり、他のコンポーネントがデータの管理と使用をサポートするために設計されていることが保証されます。
  - 例: ChatGPT、検索エンジン
- データフローアーキテクチャ
  - データフローアーキテクチャ（data flow architecture）では、システムは独立したコンポーネントの集合体として設計され、各コンポーネントが特定の機能を担当し、データはこれらのコンポーネント間を流れます。データフローアーキテクチャは、リアルタイムシステム、信号処理システム、分散システムなど、大量のデータを処理する必要があるシステムでよく使われます。このアーキテクチャの主な利点は、必要に応じてコンポーネントを追加または削除することでシステムの拡張が容易になることです。
  - データフローアーキテクチャでは、データの流れを直線的なパイプラインとして表現することが一般的です。データは一つのコンポーネントから次のコンポーネントへと順次渡され、各コンポーネントはデータを変換、処理、分析、または他の操作を行います。このようなパイプラインの構造により、データの処理が効率化され、柔軟性や拡張性が向上します。
  - 例: TypeScript トランスパイラ、Web クローラ
- コール・アンド・リターンアーキテクチャ
  - コール・アンド・リターンアーキテクチャ（call-and-return architecture, CRA）では、プログラムは主に手続きや関数と呼ばれる小さな処理単位に分割されます。プログラムの実行は、メインのプログラムから手続きを呼び出し（コール）、呼び出された手続きが処理を行った後にメインのプログラムに戻る（リターン）という流れで進みます。
- レイヤードアーキテクチャ
  - レイヤードアーキテクチャ（layered architecture）では、アプリケーションを論理的なレイヤーに分割し、各レイヤーが特定の機能を提供します。通常、レイヤーは階層的に配置され、各レイヤーは下のレイヤーに依存します。レイヤーが上に行くほど、ユーザーに近くなります。一方、レイヤーが下に行くほど、オペレーティングシステムやデータベースに近くなります。
  - 例: TCP/IP プロトコル
- イベント駆動アーキテクチャ
  - システム内で何かイベント（特定の出来事）が発生した時、そのイベントに関連するソフトウェアの部品同士が、互いに非同期（同時ではなく順不同で）に通信し合って動作します。イベント駆動アーキテクチャ（event-driven architecture）では、明示的な要求（リクエスト）に頼るのではなく、イベントが起こった時に自動的に対応する仕組みです。
  - 例えば、ゲームはイベント駆動アーキテクチャを使用することが一般的です。ゲームでは、プレイヤーの入力やキャラクターの動き、衝突やトリガーの発生など、さまざまなイベントが発生します。これらのイベントに応じて、ゲームエンジンやゲーム内のオブジェクトが適切なアクションを実行します。イベント駆動アーキテクチャは、ゲーム開発において柔軟性と拡張性を提供します。ゲーム内の様々な要素（キャラクター、オブジェクト、エフェクトなど）は独立したコンポーネントとして扱われ、イベントを介して相互作用します。これにより、新しい要素を容易に追加したり、既存の要素を修正したりすることができます。
  - 例: サードパーティとの連携サポート
- クライアントサーバアーキテクチャ
  - クライアントサーバアーキテクチャ（client-server architecture）では、クライアントと呼ばれるアプリケーションがサーバと呼ばれる別のアプリケーションに対してリソースやサービスを要求します。例えば、ウェブブラウザがクライアントであり、ウェブサーバがサーバとなります。
  - 例: オンラインゲーム、ソーシャルネットワークサービス
- サービス指向アーキテクチャ
  - サービス指向アーキテクチャ（service-oriented architecture, SOA）は、ソフトウェアシステムを独立したサービスに分割し、それらのサービス間の連携と通信を可能にするアーキテクチャのアプローチです。各サービスは、特定の機能を提供し、他のサービスと組み合わせて大規模なシステムを構築するために使用されます。
  - 例: クラウドコンピューティングサービス
- P2P アーキテクチャ
  - ピア・ツー・ピアアーキテクチャ（peer-to-peer architecture）は、ネットワーク上のコンピューターシステムやアプリケーションの間で直接的な相互接続を可能にする分散型のアーキテクチャです。このアーキテクチャでは、コンピューター（ピア）同士が対等な地位で通信し、リソースや情報を共有できます。
  - P2P アーキテクチャでは、中央集権的なサーバが必要なく、各ピアが自己組織化されたネットワークを形成します。ピアは同時にクライアントとサーバの役割を果たし、他のピアに対してリソースを提供することができます。データやファイルはピア間で直接転送され、ピアが相互にリクエストや応答を行います。
  - 例: ブロックチェーン

## アーキテクチャパターン
アーキテクチャスタイルは、システム全体またはその一部の一般的な構造を示すものです。つまり、システムの設計の基本的な枠組みやレイアウトのことです。これは、高いレベルで抽象化されており、具体的な実装の詳細には触れません。 一方、アーキテクチャパターンは、具体的な問題を解決するためのルールやガイドラインのセットです。つまり、特定の要件や制約を満たすために確立された方法です。アーキテクチャパターンは、実践的な経験に基づいて検証され、効果的な解決策として認められています。  
一般的には、まず問題に適したアーキテクチャスタイルを考え、それに応じてアーキテクチャパターンを選ぶことがあります。あるいは、既に解決済みの問題に対して有効なアーキテクチャパターンが存在する場合は、それを直接利用することもできます。アーキテクチャパターンには、特定の名前が付けられており、デザイナー間のコミュニケーションに役立ちます。これらのパターン名は、多くの意味を含んでいるため、設計者が効果的に情報を伝えるのに役立ちます。
- パイプとフィルタ
  - パイプとフィルタのアーキテクチャ（Pipes and Filters Architecture）は、大量のデータを小さなチャンクに分割し、一連のステージで処理するために使用されるソフトウェア設計パターンです。
  - このアーキテクチャでは、データはフィルタと呼ばれる一連のコンポーネントを通過し、データを処理するための特定のタスクを実行するフィルタと、フィルタを接続しデータの流れを可能にするパイプを介して流れます。パイプライン内の各フィルタは、前のフィルタからデータを受け取り、処理を行い、パイプを介して次のフィルタに渡します。
  - 入出力の単純な性質のため、パイプライン内のフィルタは独立して開発、テスト、保守ができるため、個々のフィルタを変更または置換する際にシステム全体に影響を与えることなく容易に行えます。
  - アーキテクチャスタイル：データフローアーキテクチャ
  - 使用例：データ処理ソフトウェア（データパイプラインと呼ばれる）、バッチ処理システム、ETL（Extract, Transform, Load）など
- 多層アーキテクチャ
  - ソフトウェアアプリケーションを、それぞれが特定の機能を持つ異なる層に分割して整理する方法です。これは、アプリケーションがサーバー上で動作し、ユーザーがクライアントを介してアプリケーションとやりとりするクライアントサーバモデルでよく使用されます。層（ティア）の数は、アプリケーションの複雑さに応じて変えることができます。
  - 3 層アーキテクチャは、アプリケーションをプレゼンテーション、ビジネス、データストレージの 3 つの層に分離する、多層アーキテクチャの特定のタイプです。プレゼンテーション層は、Web ページやモバイルアプリのように、ユーザーに情報を表示する役割を担います。ビジネスロジック層は、データを処理し、アプリケーションのルールやロジックを実装する役割を担います。データストレージ層は、データベースなどからのデータの保存と取得を担当します。3 層アーキテクチャでは、ユーザーが操作するコードであるクライアント、ビジネスロジックのコードを含むバックエンドサーバー、アプリケーションで使用するデータを格納するデータベースの 3 つの主要コンポーネントが存在します。
  - N 層アーキテクチャは、3 層アーキテクチャを拡張したもので、より大きなスケーラビリティを可能にするために、層をさらに細分化することができます。例えば、メッセージング、個別サービス、ミドルウェア、サードパーティーの統合などのために、さらに層を追加することができます。これにより、アプリケーションはより柔軟になり、ニーズの変化に対応できるようになります。
  - アーキテクチャスタイル：レイヤードアーキテクチャ、クライアントサーバアーキテクチャ
  - 使用例：ウェブサイト、モバイルアプリ、オンラインゲーム、IoT システム
- MVCアーキテクチャ
  - MVC アーキテクチャ（model-view-controller architecture）は、ソフトウェアをモデル、ビュー、コントローラの 3 つの部分に分けて組織化する方法です。
  - モデルは、アプリケーションのデータとロジックが格納される場所です。つまり、モデルはアプリケーションのデータを管理・操作する役割を担っています。ビューは、モデルからのデータをユーザに表示する責任を持ちます。ここで、ユーザはアプリケーションのユーザインタフェースとやりとりすることになります。コントローラは、モデルとビューの間の橋渡しのようなものです。コントローラはユーザの入力を処理し、それに応じてモデルやビューを更新します。コントローラはユーザからの入力を受け取り、それをモデルに送ってデータを更新し、そしてビューを更新してユーザに新しい情報を表示します。
  - MVC を使用することで、アプリケーションをモジュール化し、保守を容易にし、理解しやすくすることができます。データ、ユーザーインターフェース、制御ロジックを異なるコンポーネントに分離することで、他のコンポーネントに影響を与えることなく、各コンポーネントの変更や更新を容易に行うことができます。
  - アーキテクチャスタイル：レイヤードアーキテクチャ
  - 使用例：ユーザーインターフェースを持つアプリケーション（Web、モバイル、デスクトップアプリ）
- マイクロサービスアーキテクチャ
  - マイクロサービスアーキテクチャ（microservices architecture）は、アプリケーションを小さな独立したサービスの集合体として開発するソフトウェア設計パターンです。これらのサービスは軽量なプロトコルを使用してネットワーク上で互いに通信し、各々が自己完結型で特定のビジネスタスクや機能を実行します。また、他のサービスとは独立して開発、展開、スケーリングが可能です。
  - これらのサービスは自律的で分散化されているため、障害箇所に対して耐性を持ち、必要に応じてスケールアップやスケールダウンが可能です。ソケット（または HTTP）を介した通信やリモートプロシージャコールを行う際に、すべてのサービスが同じプロトコルを知っているため、それぞれのサービスは異なるプログラミング言語やテクノロジースタックを使用して開発することができ、技術に依存しません。
  - アーキテクチャスタイル：サービス指向アーキテクチャ
  - 使用例：エンタープライズアプリケーション、中・大規模クライアントサーバ、データセンター、サードパーティサービス統合、クラウドコンピューティング
- Balckboardアーキテクチャ
  - Blackboard アーキテクチャ（blackboard architecture）は、異なるモジュールが共同で問題に取り組むためのソフトウェア設計方法です。モジュールはすべて、Blackboard と呼ばれる共有データ構造にアクセスし、更新することができます。Blackboard は、異なる知識源や問題解決者が情報を交換し、問題解決のために協力し合う中心的なハブとして機能します。
  - Blackboard アーキテクチャには、Blackboard、ナレッジソース、コントローラの 3 つの主要な部分があります。ナレッジソースは、問題解決のために独立して作業を行う問題解決者のような役割を持ちます。それぞれ専門分野を持ち、特定の手法で問題を分析します。コントローラは、Blackboard とナレッジソースの間の情報の流れを監督するマネージャーのようなものです。どのソースをアクティブにするかを決定し、問題解決の順序をコントロールします。
  - アーキテクチャスタイル：データ中心型アーキテクチャ
  - 使用例：A.I システム、意思決定支援システム、自然言語処理、エキスパートシステム
- メディエータートポロジーアーキテクチャ
  - メディエータートポロジーアーキテクチャ（mediator topology architecture）は、システムのさまざまな部分で発生したイベントがまずイベントキューに送られるようにシステムを組織化する方法です。次に、イベントメディエーターと呼ばれる中央のコンポーネントが、どのイベントをどのような順序で処理すべきかを決定します。メディエーターは、各イベントプロセッサで処理されたイベントを新たに生成することもできます。
  - アーキテクチャスタイル：イベント駆動型アーキテクチャ
  - 使用例：非同期トランザクション、金融取引システム、電子商取引アプリケーション、ソーシャルネットワークサービス
- ブローカートポロジーアーキテクチャ
  - ブローカートポロジーアーキテクチャ（broker topology architecture）とは、イベント駆動型アーキテクチャにおける一種の構造です。この構造では、メッセージブローカーまたはイベントバスがシステム内の他のコンポーネントから送信されるすべてのイベントを受け取り、イベントチャネルと呼ばれるものに格納します。その後、メッセージブローカーはイベントの内容に基づいて、それぞれのイベントが適切なイベントチャネルに送られるようにルーティングします。 
  - 各イベントプロセッサは、受け取ったイベントを処理し、新しいイベントを生成して再びメッセージブローカーに送信する役割を担っています。このプロセスでは、イベントの処理順序を調整するための仲介者や、処理後に新しいイベントを生成するためのメカニズムは存在しません。その結果、一連のイベントが順番に発生することがよくあります。
  - アーキテクチャスタイル：イベント駆動型アーキテクチャ 
  - 使用例：非同期トランザクション、金融取引システム、電子商取引アプリケーション、ソーシャルネットワークサービス
- マスタースレーブパターン
  - マスタースレーブパターン（master-slave pattern）とは、分散システムのアーキテクチャの一種で、マスターと呼ばれるデバイスまたはプロセスが、スレーブと呼ばれる他のデバイスまたはプロセスを制御します。マスターはシステム全体の動作を制御し、スレーブはマスターから割り当てられた特定のタスクを実行します。スレーブノードは互いに直接通信することはできず、代わりにマスターノードを介して通信します。
  - アーキテクチャスタイル：メイン-サブルーチンアーキテクチャ
  - 使用例： データベースレプリケーション、Web クラスタ、並列計算、ロボティクス

## 詳細設計
この段階では、アーキテクチャの特定の部分に焦点を当て、その部分の手順の説明を記述します。この説明は、具体的な要件をソフトウェアに翻訳する役割を果たします。要件とモデルはソフトウェアが何をする必要があるかを指定しますが、詳細設計はコードがそれをどのように実行するかを指定します。  
設計書は説明を提供するだけで、実装の詳細は開発プロセスのコーディング部分に委ねられます。ソフトウェアエンジニアは詳細設計を作成し、書く予定のソフトウェアが機能することを確認します。そのため、詳細設計はソフトウェアの品質と開発効率に関係しています。
- ソフトウェアの品質
  - ソフトウェアの品質とは、要求モデルに含まれるすべての機能要件と非機能要件を実装し、利害関係者の要望にも対応することを意味します。詳細設計では、要件の収集と分析の段階ですべての要件が定義されていると仮定する場合（ウォーターフォールモデル）、またはフィードバックループを持つ反復開発によってソフトウェアが開発されていると仮定する場合（アジャイル開発）ともに対応します。
  - アジャイル開発では、設計はエンドユーザー、ターゲット市場、投資家などの利害関係者の要望に焦点を当てるべきです。アジャイル環境では、反復が進むにつれて要件が追加、更新、削除される傾向があります。高品質なソフトウェアを確保するためには、カバーされるべき一般的なプラクティスに従う必要があります。
- 開発効率
  - 開発効率とは、ソフトウェアを開発・維持する際の効果的な取り組み方を指します。詳細な設計を行うことで、ロジックが具体的にどのように機能するかを考え、実装方法をアイデア出しします。これにより、実装の観点から問題を解決する方法を考える自由が生まれ、作業を始める前に品質を保証できます。
  - 詳細な設計に十分な考慮をせず、またはそれをスキップすることは非効率です。なぜなら、ソフトウェア開発のこの段階では開発コストが最も低いからです。詳細設計中の実装変更にかかるコストは、コーディング中の実装変更に比べてほぼゼロです。実装変更にかかるコストは時間の経過とともに指数関数的に増加します。コーディングが完了した後、品質保証（QA）中や本番リリース後の実装変更にかかるコストは、10 倍ずつ増加します。そのため、ソフトウェアを効率よく、低コストで開発するためには、詳細設計フェーズに時間をかけることが重要です。
- 詳細設計
  - 詳細設計には、2 つの種類の設計があります。ひとつは「コンポーネントレベルの設計」で、もうひとつは「ユーザーエクスペリエンス/ユーザーインターフェース（UI/UX）の設計」です。
  - コンポーネントレベルの設計では、コンポーネントの構造や実装方法、他のコンポーネントとの連携方法などの詳細が提供されます。一方、UI/UX 設計は、ソフトウェアとユーザーの間の相互作用に関わる部分に焦点を当てます。コンポーネントレベルの設計は、ユーザーから見えないソフトウェアの部分を中心に取り扱いますが、UI/UX 設計はユーザーが見て使うソフトウェアの部分に注力します。なお、これらの詳細設計は同時並行して進めることもあり、UI/UX 設計もコンポーネントレベルの設計に基づいています。
  - アーキテクチャはプロジェクトの初めやシステム全体の段階で主に設計されますが、詳細設計はソフトウェアに対して行われるあらゆる変更や機能追加、コンポーネントの更新やリファクタリング、コーディングなどの作業に適用されます。例えば、新しい機能を追加する場合、詳細設計ではその機能がどのように実装されるか、どのコンポーネントと連携するか、具体的な手順や仕様が詳細に定義されます。また、既存のコンポーネントを更新したり、コードの再構築（リファクタリング）を行ったりする場合も、詳細設計が必要となります。

### コンポーネントレベルの設計
コンポーネントレベルの設計とは、モジュールやサブシステムのような個々のソフトウェアコンポーネントを個別に設計・開発するソフトウェア開発プロセスです。各コンポーネントは特定の機能を念頭に置いて設計され、他のコンポーネントとの相互作用が定義されます。  
コンポーネントレベルの設計の目的は、モジュール化された再利用可能なソフトウェアコンポーネントを作成し、大規模なシステムに容易に統合してテストできるようにすることです。このアプローチにより、開発者は複雑なシステムをより小さく管理しやすいコンポーネントに分解することができ、ソフトウェアシステムの設計、実装、テスト、および保守が容易になります。これらのコンポーネントが組み合わされると、ソフトウェアシステム全体が形成されます。  
各コンポーネントは、単一責任の原則に従い、1 つの主要なタスクに焦点を当てます。

#### 手順
1. システムを管理しやすい小さなコンポーネントに分解する。
2. コンポーネント間のインターフェースと相互作用を定義する。
3. 各コンポーネントの開発プロセスに従う。
   1. （要件）コンポーネントの機能要件または目的を特定する。
   2. （設計）各コンポーネントの内部構造を設計する。
   3. （コード/テスト）各コンポーネントを個別に実装し、テストする。
   4. （デプロイメント）コンポーネントをより大きなシステムへ統合する。
4. システム全体をテストして、コンポーネントがうまく統合されていることを確認する。

このステップでは、コラボレーションダイアグラムを作成し、各コンポーネントのインターフェースを開発します。これらの作業は同時に行います。コンポーネントの契約、またはインターフェースとも呼ばれるものは、利用可能な機能とそれに関連する入出力値を明示します。場合によっては、契約には事前条件、事後条件、例外も定義されることがあります。
- コラボレーション図
  - システム内のコンポーネント間で交換される相互作用とメッセージを視覚化するために使用されるダイアグラムの一種です。特定のタスクや機能を達成するために、オブジェクトが互いにどのように協力し合うかを示すものです。矢印はメッセージの流れの方向を示し、メッセージの名前と流れ番号でラベル付けされています。
- コンポーネント図（UML）
  - システムのさまざまな部分と、それらが互いにどのように相互作用するかを視覚的に表現する図の一種です。ソフトウェアシステムの構造を高いレベルで詳細に示すために使用されます。
  - コンポーネント図では、システムの各部分は、特定の機能を実行する個別のコンポーネントとして示されます。これらのコンポーネントはモジュール化されており、システムの他の部分や他のプロジェクトで簡単に再利用することができます。システムが必要とする情報、作成する情報、アクセスする情報はすべてアーティファクト（artifact）と呼ばれます。
- インターフェースクラス
  - インターフェースクラスは、インターフェースを実装するクラスが必ず持つべき抽象的なメソッドやプロパティのグループを定義した設計図です。コンポーネントが期待するオブジェクトの種類を指定するために使用されます。インターフェースの主な目的は、システムの異なる部分の間で共通の合意や標準を確立することです。インターフェースは抽象的であり、実装クラスが行うべきことを概説するだけで、それをどのように行うべきかの詳細を提供するものではありません。

#### コンポーネントの詳細
1. 公開インターフェースの明確化
   - 他のコンポーネントが使用するためのすべての公開メソッドを定義します。手順と入出力の説明を含めます。
2. データ設計
   - オブジェクトの構造、内部状態、および使用されるデータ型または構造について詳細に説明します。内部状態は、クラスが保持する変数で構成されます。これらのデータ構造は、プリミティブ型、複合型、または合成クラスのいずれかである場合があります。これらのデータ構造は、コンポーネントの依存関係である場合もありますし、コンポーネントだけが使用できるように隠され、他のコンポーネントに再利用されることはありません。
3. 各プロセスの手順の説明
   - 各プロセスは高い凝集性を持ち、特定のタスクに焦点を当てます。コンピュータがどのようにそのプロセスを実行するかを論理的な手順で説明します。この説明はアクティビティダイアグラムを使用することもあります。
   
- UMLクラス図
1. 分析クラス
  - 分析クラス（analysis class）は問題領域を徹底的に分析します。これには、問題の性質や要件の理解、関連するデータやプロセスの把握などが含まれます。この分析によって、問題を解決するために必要な属性（データや情報の特徴）、操作（クラスが行う操作や機能）、他のクラスとの関係などが特定されます。
  - 属性は、クラスが持つデータや情報の特徴を表します。たとえば、顧客クラスの属性には「氏名」「住所」「電話番号」などが含まれるでしょう。操作は、クラスが実行する特定の機能や操作を表します。たとえば、注文クラスの操作には「商品の追加」「合計金額の計算」「注文の確定」などが含まれるかもしれません。
  - これには、異なるクラスが互いにどのように関連しているかという情報（集約やコンポジション）が含まれます。
2. 詳細な設計クラス
  - 解析クラスから派生したもので、設計クラスには解析クラスの属性や操作だけでなく、可視性、アクセス制御、継承、インターフェース、必要なデータ構造やアルゴリズムなどの追加の詳細も含まれます。設計クラスは、オブジェクト間の関係（継承、組成、関連）の実装も担当しています。
3. 説明を追加
  - 最後のステップは、各プロセスをより小さなステップに分解して、説明を追加することです。特定のメソッドを見て、何が起こるかをステップバイステップで説明することができます。各ステップの前後で何が必要なのか、どのような問題が発生するのか、どのような入力値や出力値が関係しているのかなど、詳細な情報を盛り込むことができます。これを視覚的に示す方法として、アクティビティ図があります。データ構造、アルゴリズム、プログラミングの経験があれば、その詳細や制約を把握しやすくなります。
  - また必要であれば、状態図を使用して、各ステップの前後に何が必要かを示す追加情報を提供することができます。例えば、ある関数が呼び出される前と後で、その関数の状態がどのようになるかを示す必要があるかもしれません。またエントリポイント関数や while ループのように、異なるイベントや状態を伴う場合、複雑な関数がどのように動作するかを把握することができます。これは、プロセスが要求される品質基準を満たすことを保証するのに役立ちます。

# デザインパターン
- ソフトウェア開発の品質と効率を向上させるための基本原則

## 抽象化（abstraction）
抽象化とは、ソフトウェア工学において、開発プロセスを簡略化するために用いられる技法です。システムの最も重要な機能を特定し、無関係な細部を無視します。これにより、開発者はより理解しやすく、使いやすいモデルやインターフェースを作成することができます。

## 関心の分離（separation of concerns）
関心の分離とは、複雑なシステムをより小さく、より管理しやすい部分に分割し、それぞれが特定の責任を持つようにすることである。これにより、複雑さを軽減し、モジュール性を高め、システムの保守と修正を簡素化することができます。

## 高凝集・低結合（high-cohesion, low-coupling）
凝集性とは、モジュールやコンポーネントの要素がどれだけ互いに関連しているかを意味します。結合力の高いモジュールには、明確で集中した目的があり、すべての要素がその目的を達成するために協力し合います。結合度とは、モジュールやコンポーネントが互いにどの程度依存しているかを意味します。結合度の低いモジュールは独立性が高く、システムの他の部分に影響を与えることなく修正や置き換えが可能です。ソフトウェアシステムは、高凝集と低結合を持つことを目標とする必要があります。

## モジュール性（modularity）
モジュール化とは、システムを独立したモジュールに分割し、それぞれを開発、テスト、保守することでシステムを構成する方法です。このアプローチにより、柔軟性、拡張性、保守性が向上します。

## 拡張性（extensibility）
拡張性とは、ソフトウェアシステムを拡張したり変更したりして、新しい機能や特徴を追加することが容易であることを指します。

## 情報隠蔽（information hiding）
情報隠蔽とは、モジュールやコンポーネントの実装の詳細をシステムの他の部分から隠すことを指します。これにより、開発者はシステムの残りの部分に影響を与えることなく、モジュールの実装を変更することができます。カプセル化と同様に、コントラクトやインターフェースがよく使われます。

## 独立性（independence）
独立性とは、システムの異なるコンポーネント間で、機能面でも実装面でも、どの程度隔離されているかを示すものです。これにより、複雑さを軽減し、柔軟性を高めることができます。

## リファクタリング（refactoring）
リファクタリングとは、コードの動作を変えずに、品質と保守性を向上させるためにコードを再構築するプロセスのことです。リファクタリングでは通常、コードを単純化し、重複を減らし、モジュール性と可読性を向上させるための変更を行います。

## DRY（Don't Repeat Yourself）
開発者は可能な限りコードの重複を避けるべきという慣習です。DRYの背景にある考え方は、コードを DRY に保つことで、開発者が書くべきコードの量を減らし、コードの保守性を向上させ、コードを拡張する必要がある場合に不要な作業を避けることができるというものです。

## KISS（Keep It Simple Stupid）
ソフトウェア設計におけるシンプルさの重要性を強調するものです。開発者が物事をシンプルに保つことで、コードが読みやすくなり、複雑さが軽減され、バグが発生するリスクを最小限に抑えることができます。

## YAGNI（You Ain't Gonna Need It）
開発者は絶対に必要な機能だけを追加するように気をつけるという慣習です。必要な機能と要件に集中することで、開発者は開発期間とコストを削減し、複雑さを軽減してコード品質を向上させることができます。要件を分析することと、必要に応じてコードベースを拡張できるようにソフトウェアを設計することの間で、適切なバランスを見つけることが重要です。これは、アジャイル開発環境では特に重要です。

# SOLID
プログラミングパラダイムには、そのパラダイムの利点を活かすためにエンジニアが従うべき原則があります。オブジェクト指向プログラミングでは、SOLID の原則に従うのが一般的です。

## 単一責任原則（Single Responsibility Principle）
クラスは 1 つの仕事または責任だけを持つべきだという意味です。また、クラスが果たすべき責任や仕事は 1 つだけであるべきです。この原則は、モジュール化と関心の分離を促進し、システムの他の部分に影響を与えることなくクラスの機能を変更または拡張することを容易にするものです。


## オープン/クローズド原則（Open/Closed Principle）
OCP とは、ソフトウェアの実体（クラス、モジュール、関数など）は、拡張に対してはオープンであるが、変更に対してはクローズであるべきであるというものです。新しい要求が生じたとき、あるいはシステムを拡張する必要が生じたとき、既存のコードを変更するのではなく、新しいコードを追加することで拡張できるようにする必要があります。このアプローチにより、バグの発生や既存機能の破壊のリスクを最小限に抑えることができます。これは、継承や合成によって拡張できる、明確で安定したインターフェースを持つソフトウェアモジュールを設計することによって部分的に達成されます。


## リスコフ置換原則（Liskov Substitution Principle）
「サブクラスは、そのスーパークラスが期待されるところならどこでも、問題を起こしたりプログラムの機能を壊したりすることなく使用できるべきである」とするものです。これは、サブクラスがスーパークラスのすべての動作を継承しているため、シームレスに置き換えることができる必要があるためです。


たとえば、Animal というクラスを使用するプログラムがあり、このクラスには makeSound() というメソッドがあるとします。ここで、Dog というサブクラスを作成するとします。このサブクラスは Animal から継承され、makeSound() メソッドも持っていますが、Animal クラスとは異なる音を生成します。Animal クラスのオブジェクトの代わりに Dog クラスのオブジェクトを使用しても、プログラムは正常に動作するはずです。なぜなら、Dog クラスは Animal クラスのサブタイプであり、Animal クラスが持つすべてのメソッドを実装しているためです。


インターフェース分離の原則（Interface Segregation Principle）
ソフトウェアのインターフェースは、特定のタスクや機能に必要なメソッドのみを含む、集中的でまとまりのある設計にすべきとするプログラミングの原則です。この原則では、クライアントが使用しないメソッドに依存することを強いられることはなく、インターフェースは可能な限り具体的かつ最小限のものであるべきであることを強調しています。


例えば、プリンタを使って文書を印刷するソフトウェアシステムを設計していると想像してください。プリンタインタフェースには、print()、scan()、copy()、fax() などのメソッドが用意されていることでしょう。しかし、プリンタインターフェースのすべてのクライアントが、これらのメソッドをすべて必要とするわけではありません。例えば、文書を印刷するために print() メソッドだけを必要とするクライアントもあれば、文書のコピーを作成するために copy() メソッドを必要とするクライアントもあるでしょう。


プリンタインタフェースが ISP を意識して設計されていない場合、インタフェースのすべてのクライアントが、たとえそれらを必要としなくても、すべてのメソッドを実装しなければならないことになります。これは不必要な複雑化を招き、エラーやバグのリスクを高めることになります。一方、ISP を意識したプリンタインタフェースであれば、各クライアントに必要なメソッドのみを実装することになり、使い勝手やメンテナンスが容易になります。結果として、print()メソッドのみ必要な場合、その関数だけ定義するPrintableインターフェース作成します。


したがって、ISP の原則は、各クライアントにとって必要なメソッドのみを含む、具体的で最小限のインターフェースの設計を促進します。これにより、インターフェースの理解、実装、保守が容易になり、システムにエラーやバグが発生するリスクを低減することができます。


## 依存関係逆転の原則（Dependency Inversion Principle）
DIP とは、プログラミングの原則の一つで、高位モジュールは具体的な実装ではなく、抽象的なものに依存すべきとするものです。つまり、高レベルのモジュールが低レベルのモジュールに直接依存するのではなく、両者の間に抽象化レイヤーを導入するべきだということです。


従来、私たちはコードを書くとき、低レベルのモジュールに依存する高レベルのモジュールを作成する傾向がありました。例えば、メッセージングシステムを構築する場合、MessageSender という高レベルのモジュールを用意し、SmtpClient という低レベルのモジュールに依存して、電子メールでメッセージを送信することが考えられます。


しかし、この方法の問題点は、メッセージの送信方法を変更したい場合、例えば、電子メールを使う方法から SMS を使う方法に変更したい場合、MessageSender のコードを直接変更する必要があることです。特に MessageSender のコードが複雑で多くの依存関係がある場合、これは困難でエラーが発生しやすくなる可能性があります。


DIP では、別のアプローチを提案しています。MessageSender モジュールを SmtpClient モジュールに直接依存させるのではなく、両者の間に抽象化レイヤーを導入するのです。IMessageSender というインターフェースを作成し、MessageSender モジュールが SmtpClient モジュールから必要とする機能を定義します。MessageSender モジュールはこの IMessageSender にのみ依存し、入力で受け取ります。SmtpClient モジュールの具体的な実装には依存しなくても、どんなIMessengerSender でも対応します。


これで、電子メールの利用から SMS の利用に切り替えたい場合、SMS でメッセージを送信する IMessageSender インタフェースの新しい実装、SMSClient を作成します。SmtpClientではなく、SMSClient 渡しても MessageSender モジュールはそのまま動作を継続します。これは、MessageSender モジュールが抽象化にのみ依存し、具体的な実装には依存しないためです。