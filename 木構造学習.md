# 木構造
- 頂点から出発し、同じ頂点に戻る閉路のこと
    - 頂点orノード：個々の要素
    - 辺：2つの要素間の関係
    - 親と子の関係にある階層の表現に便利

## 木と森
- 木
    - 辺が一度だけ連結される、かつ非周期
    - `E = V - 1`
- 森
    - 非周期
- 根ノード(ルート)
    - 一番上の区別されたノード
- 根付き木
    - 根ノードをもつ木
    - 先祖
        - 1->2->3のパスで1,2,3はノード3の先祖
    - 子孫
        - 1->2->3のパスで1,2,3はノード1の子孫
    - 部分木
        - それ自身も完全な木構造となっている部分
    - 親
    - 子
    - 兄弟
    - 葉ノード
    - 高さ
        - 子孫の葉ノードへの辺の数の最大値
        - 葉ノードを0として上へ良く毎に+1
    - 深さ
        - 根ノードを0として葉ノードへ良く毎に+1
    - 階層
        - 深さxのすべてのノードが存在する領域

## 二分木
- 根付き木構造で、あるノードが持つ子の数が最大で2つであるもの
- データ探索をlog nで実現可能
- 2つのパスで分岐する再帰的な問題で多く出現
- 全二分木
    - すべてのノードが「葉であるか、二つの子を持っている」
- 完全二分木
    - 全ての葉ノードが同じ「深さ」
    - 葉ノードの数 2のh乗
    - 葉ノード以外の内部ノードの合計は2のh乗-1
    - 葉ノードを含めた、最大のノード数は2(h+1)乗-1
    - 高さはlog2乗n
- 二分探索木(BST BinarySearchTree)
    - 左の子孫の値 <= 親の値 <= 右の子孫の値
    - 値xの根ノードを持ち、すべてのノードがxより小さい値を持つ左の二分探索木構造、すべてのノードがxより大きい値を持つ右の二分探索木構造を持つ
    - O(logn)の時間を要する
- 平衡二分探索木
    - 根ノードから各葉までの高さができるだけ等しくなった構造
    - ソート済みのリストをBSTに移行することで実装可能
        - startindex, endindex, 中間の根ノードを設定後、再帰関数でstartindexからmid-1まで左側の部分木へ、mid+1からendindexまでを右側の部分木へ設定
    -

```js
class BinaryTree{
    constructor(data, left = null, right = null){
        this.data = data;
        this.left = left;
        this.right = right;
    }
}

class BinarySearchTree{
    constructor(arrList){
        let sortedList = arrList.sort(function(a, b) {return a - b;});
        this.root = BinarySearchTree.sortedArrayToBST(sortedList);
    }

    static sortedArrayToBST(array) {
        if(array.length == 0) return null;
        return BinarySearchTree.sortedArrayToBSTHelper(array, 0, array.length-1);
    }

    static sortedArrayToBSTHelper(arr, start, end) {
        if(start === end) return new BinaryTree(arr[start], null,null);

        let mid = Math.floor((start+end)/2);

        let left = null;
        if(mid-1 >= start) left = BinarySearchTree.sortedArrayToBSTHelper(arr, start, mid-1);

        let right = null;
        if(mid+1 <= end) right = BinarySearchTree.sortedArrayToBSTHelper(arr, mid+1, end);

        let root = new BinaryTree(arr[mid], left, right);
        return root;
    }

    keyExist(key){
        let iterator = this.root;
        while(iterator != null){
            if(iterator.data == key) return true;
            if(iterator.data > key) iterator = iterator.left;
            else iterator = iterator.right;
        }

        return false;
    }

    search(key){
        let iterator = this.root;
        while(iterator != null){
            if(iterator.data == key) return iterator;
            if(iterator.data > key) iterator = iterator.left;
            else iterator = iterator.right;
        }

        return null;
    }
}

let balancedBST = new BinarySearchTree([1,2,3,4,5,6,7,8,9,10,11]);
console.log(balancedBST.keyExist(6));
console.log(balancedBST.search(6));
console.log(balancedBST.keyExist(2));
console.log(balancedBST.search(2));
console.log(balancedBST.search(34));
```
